{"tagline":"Low-level driver for instrumenting Android applications.","body":"# Brazenhead\r\n[![Build Status](https://secure.travis-ci.org/leandog/brazenhead.png?branch=master)](http://travis-ci.org/leandog/brazenhead)\r\n\r\nA low-level driver for testing android applications.\r\n\r\n## Basic Usage\r\n\r\nBrazenhead works by modifying your Android application (apk).  Once modified and installed in an emulator or device, brazenhead can send request to the emulator or device and cause it to interact with your application via the [Robotium API](http://code.google.com/p/robotium/).\r\n\r\n### Prerequisites\r\n\r\nBefore being able to instrument your application, you will need to add the `INTERNET` permission to your `AndroidManifest.xml`.\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n```\r\n\r\n### Starting Instrumentation\r\n\r\nTo start instrumenting an application you must create an instance of the `Brazenhead::Server` by giving it the path to your android application (apk) an optionally some keystore information.  (**_note:_** _If no keystore information is provided, the `debug.keystore` will be used instead._)\r\n\r\n```ruby\r\nrequire 'brazenhead/server'\r\n\r\n# using the debug.keystore\r\nserver = Brazenhead::Server.new \"some/path/to/my.apk\"\r\n```\r\n\r\nNow that you have a server instance, you can simply start any activity by giving it the name of the activity.  `brazenhead` will assume that it is a relative path based on the package name of your application.  If the package of your application is `com.example.some.awesome.app`, you can simply start the activity at `com.example.some.awesome.app.text.Flashy` like so:\r\n\r\n```ruby\r\n# create the server instance\r\nserver = Brazenhead::Server.new \"some/path/to/my.apk\"\r\n\r\n#start the activity\r\nserver.start \"text.Flashy\"\r\n```\r\n\r\n### Stopping Tests\r\n\r\nStopping the server instance is just as easy.  Simply issue the following to stop the test server:\r\n\r\n```ruby\r\nserver.stop\r\n```\r\n\r\n### Sending Commands\r\n\r\nMessages sent to the emulator are json messages and  must take the form of \r\n\r\n````ruby\r\n{ \r\n  name: 'theMethodName',  # The Robotium method to call\r\n  arguments: [1, 2, 3],   # The arguments to be passed to the Robotium method\r\n  variable: \"@@variable_name_to_store_the_results@@\",  # optional parameter to store the results \r\n                                                       # of a call - can be used in subsequent calls\r\n  target:  'Robotium'     # optional parameter.  Valid values are 'Robotium' or 'LastResultOrRobotium'\r\n}\r\n````\r\n\r\nThe `variable` parameter can be used in subsequent calls as an argument value.\r\n\r\nIn addition to a server process there is a ruby module that will build the json for you when you call corresponding methods.  Let's take a look at a few examples of how this works.\r\n\r\nYou can include the `Brazenhead` module in your class to provide the abilities.\r\n\r\n````Ruby\r\nclass MyClass\r\n  include Brazenhead\r\nend\r\n````\r\n\r\nOnce you do this you can call methods on an instance of `MyClass`.  These methods look like this:\r\n\r\n### Calling a single method\r\n````Ruby\r\nmy_class.scroll_down  # call the scrollDown method on Robotium\r\n````\r\n\r\nYou can also pass parameters to methods like this:\r\n\r\n````Ruby\r\nmy_class.click_on_text('Content')  # will call the method clickOnText passing 'Content'\r\n````\r\n\r\n\r\n### Calling multiple methods\r\n````Ruby\r\nmy_class.chain_calls do |driver|\r\n  driver.scroll_down                         # call scrollDown first\r\n  driver.scroll_up({:target => 'Robotium'})  # then call scrollUp\r\nend\r\n````\r\n\r\nIn the case above we had to pass a `target` value to inform the server that we wished to make the second call directly on Robotium instead of on the return call from the previous call.  You can easily make the second call on the return value from the first call like this:\r\n\r\n````Ruby\r\nmy_class.chain_calls do |driver|\r\n  driver.get_current_list_views\r\n  driver.size\r\nend\r\nmy_class.last_response.body.should == '1'\r\n````\r\n\r\nIn the above example the `size` method is called on the result of the call to `getCurrentListViews`.  If you want to use the result of a previous call as an argument in another call you can do this:\r\n\r\n\r\n````Ruby\r\nmy_class.chain_calls do |driver|\r\n  driver.get_text('Graphics', {:variable => \"@@graphics@@\"})\r\n  driver.click_on_view(\"@@graphics@@\", {:target => 'Robotium'})\r\nend\r\n````\r\n\r\nIn this final case we saved the result of the first call into a variable named `\"@@graphics@@\"` and used it as an argument in the second call.\r\n\r\n## Known Issues\r\n\r\nSee [http://github.com/leandog/brazenhead/issues](http://github.com/leandog/brazenhead/issues)\r\n\r\n## Contribute\r\n \r\n* Fork the project.\r\n* Test drive your feature addition or bug fix. Adding specs is important and I will not accept a pull request that does not have tests.\r\n* Make sure you describe your new feature with a cucumber scenario.\r\n* Make sure you provide RDoc comments for any new public method you add. Remember, others will be using this gem.\r\n* Commit, do not mess with Rakefile, version, or ChangeLog.\r\n  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)\r\n* Send me a pull request. Bonus points for topic branches.\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2012 Jeffrey S. Morgan, Levi Wilson. See LICENSE for details.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Brazenhead"}